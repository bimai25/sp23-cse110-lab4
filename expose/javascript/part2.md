1. Line 12 will print 3. `i` was defined as a var which has function scope. Line 12 and `i` are in the same function scope, so `console` has access to `var i` and will print the length of the `prices` array since `i` is reassigned up to the length of the `prices` array per its for loop.
2. Line 13 will print 150. Similar to 1, `discountedPrice` was initialized as a `var` so it has function scope. The for loop reassigns `discountedPrice` to the calculated discounted price for each entry in `prices`, and since the for loop terminates before line 13, `discountedPrice` has the last calculated discounted price which would be 300 * (1-0.5) = 150.
3. Line 14 will print 150. By similar logic of 2, `finalPrice` has function scope as it was initialized as a `var`. Since the for loop terminates before line 14, `finalPrice` holds the last calculation it performed which is round(150*100) / 100 = 150.
4. The function will return the array `discounted` which with the inputs on line 19 will contain [ 50, 100, 150 ]. `discounted` was initialized as a `var` so it has function scope. Because the only return statement is `discounted` and `var` can be initialized as whatever data type is assigned to it, the `discounted` array is returned.
5. This will throw an error. `i` is defined as a `let` and therefore its scope is contained to the for loop on line 6. The console does not have access to `i` at line 12 and an error is thrown.
6. This will also throw an error. `discountedPrice` is defined as a `let` and therefore has block scope, in this case in respect to the for loop on line 6. `discountedPrice` becomes out of scope on line 13 and as such an error is thrown.
7. Line 14 will return 150. While `finalPrice` is defined as a `let`, it is defined in the same block as the print statement on line 14. Therefore, the console has access to whatever `finalPrice` is assigned to. The for loop also has read/write access to `finalPrice` since it was defined in a parent block. Therefore `finalPrice` holds the final calculation that was performed in the for loop.
8. The function will return the array `discounted` which will contain [ 50, 100, 150 ]. `discounted` was initialized as a `let` and thefore the whole function has access to it. It will contain all the `finalPrices` that were pushed by the for loop.
9. This will throw an error as this is similar to 5. `i` was defined as a `let` in the for loop block, so therefore its scope is only in respect to the for loop. The print statement is outside the for loop and therefore does not have access to `i`. It is undefined at line 11 and the code throws an error.
10. Line 12 will return 3. `length` was defined as a `const` at the beginning and top of the function so the print statement is within its scope. Additionally, length was never reassigned so there would be no errors that contradict the `const` property. The length of the input array is 3, so 3 is printed out.
11. The function will return the array `discounted` which will contain [ 50, 100, 150 ]. While `discounted` was assigned as a `const`, this only means that `discounted` cannot be reassigned. It was mutated by the for loop with the `push` function which is legal since `discounted` is of an array type.
12. **A:** student.name |  **B:** student["Grad Year"] | **C:** student.greeting | **D:** student["Favorite Teacher"].name | **E:** student.courseLoad[0]
13. **A:** '3' + 2 yields '32'. 2 is mapped to its string representation '2', and the two existing strings are concatenated. | **B:** '3' - 2 yields 1. Since strings don't have a - operand, '3' is mapped to its integer equivalent 3, and 3-2 is evaluated as an arithmetic expression. | **C:** 3 + `null` yields 3. `null` maps to a 0 and 3+0 is evaluated. | **D:** '3' + null yields '3null'. `null` is mapped to its string equivalent 'null' and string concantenation is executed. | **E:** `true` + 3 yields 4. `true` maps to 1 and 1+3 is evaluated. | **F:** `false` + `null` yields 0. Both `false` and `null` map to 0 and 0+0 is evaluated. | **G:** '3' + `undefined` yields '3undefined'. `undefined` maps to its string equivalent 'undefined' and string concatenation is executed. | **H:** '3' - `undefined` yields NaN. Both '3' and `undefined` are mapped to their numeric equivalents. However, since `undefined` maps to NaN, 3-NaN is NaN.
14. **A:** `true`, '2' is converted into a number and 2 > 1 is a true statement. | **B:** `false`, the strings are compared in "lexicographical" order. The comparison asks the question "Does 2 come before 1 in Unicode?". The answer is no, so `false` is returned. | **C:** `true`, '2' is converted into a number and 2==2 is a true statement. | **D:** `false`, we use the strict equality operator. Since 2 is a number and '2' is a string, they are different data types and we immediately return `false`. | **E:** `false`, true is converted into its number equivalent 1, and 1 == 2 is a false statement. | **F:** `true`, `Boolean(2)` is converted to true by its conversion and since both values are of the same type, the strictly equal operator evaluates on the two values and returns `true`.
15. The `==` operator will do the comparison with the respected type conversions to numbers if the two compared types are different. The `===` operator will check the types first, and if they are different will immediately return `false`. It will not do the type conversions.
16. [JS File](./part2-question16.js)
17. This function will return the array [2, 4, 6]. `modifyArray` takes in 2 parameters an input `array` and a `callback` function. We iterate through `array` and assign new values to `newArr` which is returned. When iterating through `array` we add new values to `newArr` by calling `callback` which says to double the number at the current index of `array`.
18. [JS File](./part2-question18.js)
19. The output is 1, 4, 3, 2 with each number on their own line.